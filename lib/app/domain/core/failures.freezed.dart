// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$ValueFailureTearOff {
  const _$ValueFailureTearOff();

// ignore: unused_element
  ExceedingLength<T> exceedingLength<T>(
      {@required T failedValue, @required int max}) {
    return ExceedingLength<T>(
      failedValue: failedValue,
      max: max,
    );
  }

// ignore: unused_element
  Empty<T> empty<T>({@required T failedValue}) {
    return Empty<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  Multiline<T> multiline<T>({@required T failedValue}) {
    return Multiline<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  ListTooLong<T> listTooLong<T>({@required T failedValue, @required int max}) {
    return ListTooLong<T>(
      failedValue: failedValue,
      max: max,
    );
  }

// ignore: unused_element
  InvalidEmail<T> invalidEmail<T>({@required T failedValue}) {
    return InvalidEmail<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  ShortPassword<T> shortPassword<T>({@required T failedValue}) {
    return ShortPassword<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  WeakPassword<T> weakPassword<T>({@required T failedValue}) {
    return WeakPassword<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  ShortString<T> shortString<T>({@required T failedValue}) {
    return ShortString<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidDate<T> invalidDate<T>({@required T failedValue}) {
    return InvalidDate<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidMinimumDate<T> invalidMinimumDate<T>({@required T failedValue}) {
    return InvalidMinimumDate<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidInt<T> invalidInt<T>({@required T failedValue}) {
    return InvalidInt<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidDouble<T> invalidDouble<T>({@required T failedValue}) {
    return InvalidDouble<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidPriceComparation<T> invalidPriceComparation<T>(
      {@required T failedValue}) {
    return InvalidPriceComparation<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidUrl<T> invalidUrl<T>({@required T failedValue}) {
    return InvalidUrl<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidPhoneNumber<T> invalidPhoneNumber<T>({@required T failedValue}) {
    return InvalidPhoneNumber<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidNumber<T> invalidNumber<T>({@required T failedValue}) {
    return InvalidNumber<T>(
      failedValue: failedValue,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $ValueFailure = _$ValueFailureTearOff();

/// @nodoc
mixin _$ValueFailure<T> {
  T get failedValue;

  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
    @required TResult multiline(T failedValue),
    @required TResult listTooLong(T failedValue, int max),
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult weakPassword(T failedValue),
    @required TResult shortString(T failedValue),
    @required TResult invalidDate(T failedValue),
    @required TResult invalidMinimumDate(T failedValue),
    @required TResult invalidInt(T failedValue),
    @required TResult invalidDouble(T failedValue),
    @required TResult invalidPriceComparation(T failedValue),
    @required TResult invalidUrl(T failedValue),
    @required TResult invalidPhoneNumber(T failedValue),
    @required TResult invalidNumber(T failedValue),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    TResult multiline(T failedValue),
    TResult listTooLong(T failedValue, int max),
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult weakPassword(T failedValue),
    TResult shortString(T failedValue),
    TResult invalidDate(T failedValue),
    TResult invalidMinimumDate(T failedValue),
    TResult invalidInt(T failedValue),
    TResult invalidDouble(T failedValue),
    TResult invalidPriceComparation(T failedValue),
    TResult invalidUrl(T failedValue),
    TResult invalidPhoneNumber(T failedValue),
    TResult invalidNumber(T failedValue),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult listTooLong(ListTooLong<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult weakPassword(WeakPassword<T> value),
    @required TResult shortString(ShortString<T> value),
    @required TResult invalidDate(InvalidDate<T> value),
    @required TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    @required TResult invalidInt(InvalidInt<T> value),
    @required TResult invalidDouble(InvalidDouble<T> value),
    @required TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    @required TResult invalidUrl(InvalidUrl<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidNumber(InvalidNumber<T> value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    TResult multiline(Multiline<T> value),
    TResult listTooLong(ListTooLong<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult weakPassword(WeakPassword<T> value),
    TResult shortString(ShortString<T> value),
    TResult invalidDate(InvalidDate<T> value),
    TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    TResult invalidInt(InvalidInt<T> value),
    TResult invalidDouble(InvalidDouble<T> value),
    TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    TResult invalidUrl(InvalidUrl<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidNumber(InvalidNumber<T> value),
    @required TResult orElse(),
  });

  $ValueFailureCopyWith<T, ValueFailure<T>> get copyWith;
}

/// @nodoc
abstract class $ValueFailureCopyWith<T, $Res> {
  factory $ValueFailureCopyWith(
          ValueFailure<T> value, $Res Function(ValueFailure<T>) then) =
      _$ValueFailureCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$ValueFailureCopyWithImpl<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  _$ValueFailureCopyWithImpl(this._value, this._then);

  final ValueFailure<T> _value;
  // ignore: unused_field
  final $Res Function(ValueFailure<T>) _then;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(_value.copyWith(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
abstract class $ExceedingLengthCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $ExceedingLengthCopyWith(
          ExceedingLength<T> value, $Res Function(ExceedingLength<T>) then) =
      _$ExceedingLengthCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue, int max});
}

/// @nodoc
class _$ExceedingLengthCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ExceedingLengthCopyWith<T, $Res> {
  _$ExceedingLengthCopyWithImpl(
      ExceedingLength<T> _value, $Res Function(ExceedingLength<T>) _then)
      : super(_value, (v) => _then(v as ExceedingLength<T>));

  @override
  ExceedingLength<T> get _value => super._value as ExceedingLength<T>;

  @override
  $Res call({
    Object failedValue = freezed,
    Object max = freezed,
  }) {
    return _then(ExceedingLength<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
      max: max == freezed ? _value.max : max as int,
    ));
  }
}

/// @nodoc
class _$ExceedingLength<T> implements ExceedingLength<T> {
  const _$ExceedingLength({@required this.failedValue, @required this.max})
      : assert(failedValue != null),
        assert(max != null);

  @override
  final T failedValue;
  @override
  final int max;

  @override
  String toString() {
    return 'ValueFailure<$T>.exceedingLength(failedValue: $failedValue, max: $max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ExceedingLength<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)) &&
            (identical(other.max, max) ||
                const DeepCollectionEquality().equals(other.max, max)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(failedValue) ^
      const DeepCollectionEquality().hash(max);

  @override
  $ExceedingLengthCopyWith<T, ExceedingLength<T>> get copyWith =>
      _$ExceedingLengthCopyWithImpl<T, ExceedingLength<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
    @required TResult multiline(T failedValue),
    @required TResult listTooLong(T failedValue, int max),
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult weakPassword(T failedValue),
    @required TResult shortString(T failedValue),
    @required TResult invalidDate(T failedValue),
    @required TResult invalidMinimumDate(T failedValue),
    @required TResult invalidInt(T failedValue),
    @required TResult invalidDouble(T failedValue),
    @required TResult invalidPriceComparation(T failedValue),
    @required TResult invalidUrl(T failedValue),
    @required TResult invalidPhoneNumber(T failedValue),
    @required TResult invalidNumber(T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return exceedingLength(failedValue, max);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    TResult multiline(T failedValue),
    TResult listTooLong(T failedValue, int max),
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult weakPassword(T failedValue),
    TResult shortString(T failedValue),
    TResult invalidDate(T failedValue),
    TResult invalidMinimumDate(T failedValue),
    TResult invalidInt(T failedValue),
    TResult invalidDouble(T failedValue),
    TResult invalidPriceComparation(T failedValue),
    TResult invalidUrl(T failedValue),
    TResult invalidPhoneNumber(T failedValue),
    TResult invalidNumber(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (exceedingLength != null) {
      return exceedingLength(failedValue, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult listTooLong(ListTooLong<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult weakPassword(WeakPassword<T> value),
    @required TResult shortString(ShortString<T> value),
    @required TResult invalidDate(InvalidDate<T> value),
    @required TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    @required TResult invalidInt(InvalidInt<T> value),
    @required TResult invalidDouble(InvalidDouble<T> value),
    @required TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    @required TResult invalidUrl(InvalidUrl<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidNumber(InvalidNumber<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return exceedingLength(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    TResult multiline(Multiline<T> value),
    TResult listTooLong(ListTooLong<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult weakPassword(WeakPassword<T> value),
    TResult shortString(ShortString<T> value),
    TResult invalidDate(InvalidDate<T> value),
    TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    TResult invalidInt(InvalidInt<T> value),
    TResult invalidDouble(InvalidDouble<T> value),
    TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    TResult invalidUrl(InvalidUrl<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidNumber(InvalidNumber<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (exceedingLength != null) {
      return exceedingLength(this);
    }
    return orElse();
  }
}

abstract class ExceedingLength<T> implements ValueFailure<T> {
  const factory ExceedingLength({@required T failedValue, @required int max}) =
      _$ExceedingLength<T>;

  @override
  T get failedValue;
  int get max;
  @override
  $ExceedingLengthCopyWith<T, ExceedingLength<T>> get copyWith;
}

/// @nodoc
abstract class $EmptyCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $EmptyCopyWith(Empty<T> value, $Res Function(Empty<T>) then) =
      _$EmptyCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$EmptyCopyWithImpl<T, $Res> extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $EmptyCopyWith<T, $Res> {
  _$EmptyCopyWithImpl(Empty<T> _value, $Res Function(Empty<T>) _then)
      : super(_value, (v) => _then(v as Empty<T>));

  @override
  Empty<T> get _value => super._value as Empty<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(Empty<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$Empty<T> implements Empty<T> {
  const _$Empty({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.empty(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Empty<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $EmptyCopyWith<T, Empty<T>> get copyWith =>
      _$EmptyCopyWithImpl<T, Empty<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
    @required TResult multiline(T failedValue),
    @required TResult listTooLong(T failedValue, int max),
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult weakPassword(T failedValue),
    @required TResult shortString(T failedValue),
    @required TResult invalidDate(T failedValue),
    @required TResult invalidMinimumDate(T failedValue),
    @required TResult invalidInt(T failedValue),
    @required TResult invalidDouble(T failedValue),
    @required TResult invalidPriceComparation(T failedValue),
    @required TResult invalidUrl(T failedValue),
    @required TResult invalidPhoneNumber(T failedValue),
    @required TResult invalidNumber(T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return empty(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    TResult multiline(T failedValue),
    TResult listTooLong(T failedValue, int max),
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult weakPassword(T failedValue),
    TResult shortString(T failedValue),
    TResult invalidDate(T failedValue),
    TResult invalidMinimumDate(T failedValue),
    TResult invalidInt(T failedValue),
    TResult invalidDouble(T failedValue),
    TResult invalidPriceComparation(T failedValue),
    TResult invalidUrl(T failedValue),
    TResult invalidPhoneNumber(T failedValue),
    TResult invalidNumber(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (empty != null) {
      return empty(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult listTooLong(ListTooLong<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult weakPassword(WeakPassword<T> value),
    @required TResult shortString(ShortString<T> value),
    @required TResult invalidDate(InvalidDate<T> value),
    @required TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    @required TResult invalidInt(InvalidInt<T> value),
    @required TResult invalidDouble(InvalidDouble<T> value),
    @required TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    @required TResult invalidUrl(InvalidUrl<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidNumber(InvalidNumber<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    TResult multiline(Multiline<T> value),
    TResult listTooLong(ListTooLong<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult weakPassword(WeakPassword<T> value),
    TResult shortString(ShortString<T> value),
    TResult invalidDate(InvalidDate<T> value),
    TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    TResult invalidInt(InvalidInt<T> value),
    TResult invalidDouble(InvalidDouble<T> value),
    TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    TResult invalidUrl(InvalidUrl<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidNumber(InvalidNumber<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class Empty<T> implements ValueFailure<T> {
  const factory Empty({@required T failedValue}) = _$Empty<T>;

  @override
  T get failedValue;
  @override
  $EmptyCopyWith<T, Empty<T>> get copyWith;
}

/// @nodoc
abstract class $MultilineCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $MultilineCopyWith(
          Multiline<T> value, $Res Function(Multiline<T>) then) =
      _$MultilineCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$MultilineCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $MultilineCopyWith<T, $Res> {
  _$MultilineCopyWithImpl(
      Multiline<T> _value, $Res Function(Multiline<T>) _then)
      : super(_value, (v) => _then(v as Multiline<T>));

  @override
  Multiline<T> get _value => super._value as Multiline<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(Multiline<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$Multiline<T> implements Multiline<T> {
  const _$Multiline({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.multiline(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Multiline<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $MultilineCopyWith<T, Multiline<T>> get copyWith =>
      _$MultilineCopyWithImpl<T, Multiline<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
    @required TResult multiline(T failedValue),
    @required TResult listTooLong(T failedValue, int max),
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult weakPassword(T failedValue),
    @required TResult shortString(T failedValue),
    @required TResult invalidDate(T failedValue),
    @required TResult invalidMinimumDate(T failedValue),
    @required TResult invalidInt(T failedValue),
    @required TResult invalidDouble(T failedValue),
    @required TResult invalidPriceComparation(T failedValue),
    @required TResult invalidUrl(T failedValue),
    @required TResult invalidPhoneNumber(T failedValue),
    @required TResult invalidNumber(T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return multiline(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    TResult multiline(T failedValue),
    TResult listTooLong(T failedValue, int max),
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult weakPassword(T failedValue),
    TResult shortString(T failedValue),
    TResult invalidDate(T failedValue),
    TResult invalidMinimumDate(T failedValue),
    TResult invalidInt(T failedValue),
    TResult invalidDouble(T failedValue),
    TResult invalidPriceComparation(T failedValue),
    TResult invalidUrl(T failedValue),
    TResult invalidPhoneNumber(T failedValue),
    TResult invalidNumber(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (multiline != null) {
      return multiline(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult listTooLong(ListTooLong<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult weakPassword(WeakPassword<T> value),
    @required TResult shortString(ShortString<T> value),
    @required TResult invalidDate(InvalidDate<T> value),
    @required TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    @required TResult invalidInt(InvalidInt<T> value),
    @required TResult invalidDouble(InvalidDouble<T> value),
    @required TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    @required TResult invalidUrl(InvalidUrl<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidNumber(InvalidNumber<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return multiline(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    TResult multiline(Multiline<T> value),
    TResult listTooLong(ListTooLong<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult weakPassword(WeakPassword<T> value),
    TResult shortString(ShortString<T> value),
    TResult invalidDate(InvalidDate<T> value),
    TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    TResult invalidInt(InvalidInt<T> value),
    TResult invalidDouble(InvalidDouble<T> value),
    TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    TResult invalidUrl(InvalidUrl<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidNumber(InvalidNumber<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (multiline != null) {
      return multiline(this);
    }
    return orElse();
  }
}

abstract class Multiline<T> implements ValueFailure<T> {
  const factory Multiline({@required T failedValue}) = _$Multiline<T>;

  @override
  T get failedValue;
  @override
  $MultilineCopyWith<T, Multiline<T>> get copyWith;
}

/// @nodoc
abstract class $ListTooLongCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $ListTooLongCopyWith(
          ListTooLong<T> value, $Res Function(ListTooLong<T>) then) =
      _$ListTooLongCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue, int max});
}

/// @nodoc
class _$ListTooLongCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ListTooLongCopyWith<T, $Res> {
  _$ListTooLongCopyWithImpl(
      ListTooLong<T> _value, $Res Function(ListTooLong<T>) _then)
      : super(_value, (v) => _then(v as ListTooLong<T>));

  @override
  ListTooLong<T> get _value => super._value as ListTooLong<T>;

  @override
  $Res call({
    Object failedValue = freezed,
    Object max = freezed,
  }) {
    return _then(ListTooLong<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
      max: max == freezed ? _value.max : max as int,
    ));
  }
}

/// @nodoc
class _$ListTooLong<T> implements ListTooLong<T> {
  const _$ListTooLong({@required this.failedValue, @required this.max})
      : assert(failedValue != null),
        assert(max != null);

  @override
  final T failedValue;
  @override
  final int max;

  @override
  String toString() {
    return 'ValueFailure<$T>.listTooLong(failedValue: $failedValue, max: $max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ListTooLong<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)) &&
            (identical(other.max, max) ||
                const DeepCollectionEquality().equals(other.max, max)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(failedValue) ^
      const DeepCollectionEquality().hash(max);

  @override
  $ListTooLongCopyWith<T, ListTooLong<T>> get copyWith =>
      _$ListTooLongCopyWithImpl<T, ListTooLong<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
    @required TResult multiline(T failedValue),
    @required TResult listTooLong(T failedValue, int max),
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult weakPassword(T failedValue),
    @required TResult shortString(T failedValue),
    @required TResult invalidDate(T failedValue),
    @required TResult invalidMinimumDate(T failedValue),
    @required TResult invalidInt(T failedValue),
    @required TResult invalidDouble(T failedValue),
    @required TResult invalidPriceComparation(T failedValue),
    @required TResult invalidUrl(T failedValue),
    @required TResult invalidPhoneNumber(T failedValue),
    @required TResult invalidNumber(T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return listTooLong(failedValue, max);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    TResult multiline(T failedValue),
    TResult listTooLong(T failedValue, int max),
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult weakPassword(T failedValue),
    TResult shortString(T failedValue),
    TResult invalidDate(T failedValue),
    TResult invalidMinimumDate(T failedValue),
    TResult invalidInt(T failedValue),
    TResult invalidDouble(T failedValue),
    TResult invalidPriceComparation(T failedValue),
    TResult invalidUrl(T failedValue),
    TResult invalidPhoneNumber(T failedValue),
    TResult invalidNumber(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (listTooLong != null) {
      return listTooLong(failedValue, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult listTooLong(ListTooLong<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult weakPassword(WeakPassword<T> value),
    @required TResult shortString(ShortString<T> value),
    @required TResult invalidDate(InvalidDate<T> value),
    @required TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    @required TResult invalidInt(InvalidInt<T> value),
    @required TResult invalidDouble(InvalidDouble<T> value),
    @required TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    @required TResult invalidUrl(InvalidUrl<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidNumber(InvalidNumber<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return listTooLong(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    TResult multiline(Multiline<T> value),
    TResult listTooLong(ListTooLong<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult weakPassword(WeakPassword<T> value),
    TResult shortString(ShortString<T> value),
    TResult invalidDate(InvalidDate<T> value),
    TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    TResult invalidInt(InvalidInt<T> value),
    TResult invalidDouble(InvalidDouble<T> value),
    TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    TResult invalidUrl(InvalidUrl<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidNumber(InvalidNumber<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (listTooLong != null) {
      return listTooLong(this);
    }
    return orElse();
  }
}

abstract class ListTooLong<T> implements ValueFailure<T> {
  const factory ListTooLong({@required T failedValue, @required int max}) =
      _$ListTooLong<T>;

  @override
  T get failedValue;
  int get max;
  @override
  $ListTooLongCopyWith<T, ListTooLong<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidEmailCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidEmailCopyWith(
          InvalidEmail<T> value, $Res Function(InvalidEmail<T>) then) =
      _$InvalidEmailCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidEmailCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidEmailCopyWith<T, $Res> {
  _$InvalidEmailCopyWithImpl(
      InvalidEmail<T> _value, $Res Function(InvalidEmail<T>) _then)
      : super(_value, (v) => _then(v as InvalidEmail<T>));

  @override
  InvalidEmail<T> get _value => super._value as InvalidEmail<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidEmail<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidEmail<T> implements InvalidEmail<T> {
  const _$InvalidEmail({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidEmail(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidEmail<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidEmailCopyWith<T, InvalidEmail<T>> get copyWith =>
      _$InvalidEmailCopyWithImpl<T, InvalidEmail<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
    @required TResult multiline(T failedValue),
    @required TResult listTooLong(T failedValue, int max),
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult weakPassword(T failedValue),
    @required TResult shortString(T failedValue),
    @required TResult invalidDate(T failedValue),
    @required TResult invalidMinimumDate(T failedValue),
    @required TResult invalidInt(T failedValue),
    @required TResult invalidDouble(T failedValue),
    @required TResult invalidPriceComparation(T failedValue),
    @required TResult invalidUrl(T failedValue),
    @required TResult invalidPhoneNumber(T failedValue),
    @required TResult invalidNumber(T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return invalidEmail(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    TResult multiline(T failedValue),
    TResult listTooLong(T failedValue, int max),
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult weakPassword(T failedValue),
    TResult shortString(T failedValue),
    TResult invalidDate(T failedValue),
    TResult invalidMinimumDate(T failedValue),
    TResult invalidInt(T failedValue),
    TResult invalidDouble(T failedValue),
    TResult invalidPriceComparation(T failedValue),
    TResult invalidUrl(T failedValue),
    TResult invalidPhoneNumber(T failedValue),
    TResult invalidNumber(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmail != null) {
      return invalidEmail(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult listTooLong(ListTooLong<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult weakPassword(WeakPassword<T> value),
    @required TResult shortString(ShortString<T> value),
    @required TResult invalidDate(InvalidDate<T> value),
    @required TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    @required TResult invalidInt(InvalidInt<T> value),
    @required TResult invalidDouble(InvalidDouble<T> value),
    @required TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    @required TResult invalidUrl(InvalidUrl<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidNumber(InvalidNumber<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return invalidEmail(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    TResult multiline(Multiline<T> value),
    TResult listTooLong(ListTooLong<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult weakPassword(WeakPassword<T> value),
    TResult shortString(ShortString<T> value),
    TResult invalidDate(InvalidDate<T> value),
    TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    TResult invalidInt(InvalidInt<T> value),
    TResult invalidDouble(InvalidDouble<T> value),
    TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    TResult invalidUrl(InvalidUrl<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidNumber(InvalidNumber<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmail != null) {
      return invalidEmail(this);
    }
    return orElse();
  }
}

abstract class InvalidEmail<T> implements ValueFailure<T> {
  const factory InvalidEmail({@required T failedValue}) = _$InvalidEmail<T>;

  @override
  T get failedValue;
  @override
  $InvalidEmailCopyWith<T, InvalidEmail<T>> get copyWith;
}

/// @nodoc
abstract class $ShortPasswordCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $ShortPasswordCopyWith(
          ShortPassword<T> value, $Res Function(ShortPassword<T>) then) =
      _$ShortPasswordCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$ShortPasswordCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ShortPasswordCopyWith<T, $Res> {
  _$ShortPasswordCopyWithImpl(
      ShortPassword<T> _value, $Res Function(ShortPassword<T>) _then)
      : super(_value, (v) => _then(v as ShortPassword<T>));

  @override
  ShortPassword<T> get _value => super._value as ShortPassword<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(ShortPassword<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$ShortPassword<T> implements ShortPassword<T> {
  const _$ShortPassword({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.shortPassword(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ShortPassword<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $ShortPasswordCopyWith<T, ShortPassword<T>> get copyWith =>
      _$ShortPasswordCopyWithImpl<T, ShortPassword<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
    @required TResult multiline(T failedValue),
    @required TResult listTooLong(T failedValue, int max),
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult weakPassword(T failedValue),
    @required TResult shortString(T failedValue),
    @required TResult invalidDate(T failedValue),
    @required TResult invalidMinimumDate(T failedValue),
    @required TResult invalidInt(T failedValue),
    @required TResult invalidDouble(T failedValue),
    @required TResult invalidPriceComparation(T failedValue),
    @required TResult invalidUrl(T failedValue),
    @required TResult invalidPhoneNumber(T failedValue),
    @required TResult invalidNumber(T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return shortPassword(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    TResult multiline(T failedValue),
    TResult listTooLong(T failedValue, int max),
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult weakPassword(T failedValue),
    TResult shortString(T failedValue),
    TResult invalidDate(T failedValue),
    TResult invalidMinimumDate(T failedValue),
    TResult invalidInt(T failedValue),
    TResult invalidDouble(T failedValue),
    TResult invalidPriceComparation(T failedValue),
    TResult invalidUrl(T failedValue),
    TResult invalidPhoneNumber(T failedValue),
    TResult invalidNumber(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (shortPassword != null) {
      return shortPassword(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult listTooLong(ListTooLong<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult weakPassword(WeakPassword<T> value),
    @required TResult shortString(ShortString<T> value),
    @required TResult invalidDate(InvalidDate<T> value),
    @required TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    @required TResult invalidInt(InvalidInt<T> value),
    @required TResult invalidDouble(InvalidDouble<T> value),
    @required TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    @required TResult invalidUrl(InvalidUrl<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidNumber(InvalidNumber<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return shortPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    TResult multiline(Multiline<T> value),
    TResult listTooLong(ListTooLong<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult weakPassword(WeakPassword<T> value),
    TResult shortString(ShortString<T> value),
    TResult invalidDate(InvalidDate<T> value),
    TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    TResult invalidInt(InvalidInt<T> value),
    TResult invalidDouble(InvalidDouble<T> value),
    TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    TResult invalidUrl(InvalidUrl<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidNumber(InvalidNumber<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (shortPassword != null) {
      return shortPassword(this);
    }
    return orElse();
  }
}

abstract class ShortPassword<T> implements ValueFailure<T> {
  const factory ShortPassword({@required T failedValue}) = _$ShortPassword<T>;

  @override
  T get failedValue;
  @override
  $ShortPasswordCopyWith<T, ShortPassword<T>> get copyWith;
}

/// @nodoc
abstract class $WeakPasswordCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $WeakPasswordCopyWith(
          WeakPassword<T> value, $Res Function(WeakPassword<T>) then) =
      _$WeakPasswordCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$WeakPasswordCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $WeakPasswordCopyWith<T, $Res> {
  _$WeakPasswordCopyWithImpl(
      WeakPassword<T> _value, $Res Function(WeakPassword<T>) _then)
      : super(_value, (v) => _then(v as WeakPassword<T>));

  @override
  WeakPassword<T> get _value => super._value as WeakPassword<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(WeakPassword<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$WeakPassword<T> implements WeakPassword<T> {
  const _$WeakPassword({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.weakPassword(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WeakPassword<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $WeakPasswordCopyWith<T, WeakPassword<T>> get copyWith =>
      _$WeakPasswordCopyWithImpl<T, WeakPassword<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
    @required TResult multiline(T failedValue),
    @required TResult listTooLong(T failedValue, int max),
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult weakPassword(T failedValue),
    @required TResult shortString(T failedValue),
    @required TResult invalidDate(T failedValue),
    @required TResult invalidMinimumDate(T failedValue),
    @required TResult invalidInt(T failedValue),
    @required TResult invalidDouble(T failedValue),
    @required TResult invalidPriceComparation(T failedValue),
    @required TResult invalidUrl(T failedValue),
    @required TResult invalidPhoneNumber(T failedValue),
    @required TResult invalidNumber(T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return weakPassword(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    TResult multiline(T failedValue),
    TResult listTooLong(T failedValue, int max),
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult weakPassword(T failedValue),
    TResult shortString(T failedValue),
    TResult invalidDate(T failedValue),
    TResult invalidMinimumDate(T failedValue),
    TResult invalidInt(T failedValue),
    TResult invalidDouble(T failedValue),
    TResult invalidPriceComparation(T failedValue),
    TResult invalidUrl(T failedValue),
    TResult invalidPhoneNumber(T failedValue),
    TResult invalidNumber(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (weakPassword != null) {
      return weakPassword(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult listTooLong(ListTooLong<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult weakPassword(WeakPassword<T> value),
    @required TResult shortString(ShortString<T> value),
    @required TResult invalidDate(InvalidDate<T> value),
    @required TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    @required TResult invalidInt(InvalidInt<T> value),
    @required TResult invalidDouble(InvalidDouble<T> value),
    @required TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    @required TResult invalidUrl(InvalidUrl<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidNumber(InvalidNumber<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return weakPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    TResult multiline(Multiline<T> value),
    TResult listTooLong(ListTooLong<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult weakPassword(WeakPassword<T> value),
    TResult shortString(ShortString<T> value),
    TResult invalidDate(InvalidDate<T> value),
    TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    TResult invalidInt(InvalidInt<T> value),
    TResult invalidDouble(InvalidDouble<T> value),
    TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    TResult invalidUrl(InvalidUrl<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidNumber(InvalidNumber<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (weakPassword != null) {
      return weakPassword(this);
    }
    return orElse();
  }
}

abstract class WeakPassword<T> implements ValueFailure<T> {
  const factory WeakPassword({@required T failedValue}) = _$WeakPassword<T>;

  @override
  T get failedValue;
  @override
  $WeakPasswordCopyWith<T, WeakPassword<T>> get copyWith;
}

/// @nodoc
abstract class $ShortStringCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $ShortStringCopyWith(
          ShortString<T> value, $Res Function(ShortString<T>) then) =
      _$ShortStringCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$ShortStringCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ShortStringCopyWith<T, $Res> {
  _$ShortStringCopyWithImpl(
      ShortString<T> _value, $Res Function(ShortString<T>) _then)
      : super(_value, (v) => _then(v as ShortString<T>));

  @override
  ShortString<T> get _value => super._value as ShortString<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(ShortString<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$ShortString<T> implements ShortString<T> {
  const _$ShortString({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.shortString(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ShortString<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $ShortStringCopyWith<T, ShortString<T>> get copyWith =>
      _$ShortStringCopyWithImpl<T, ShortString<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
    @required TResult multiline(T failedValue),
    @required TResult listTooLong(T failedValue, int max),
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult weakPassword(T failedValue),
    @required TResult shortString(T failedValue),
    @required TResult invalidDate(T failedValue),
    @required TResult invalidMinimumDate(T failedValue),
    @required TResult invalidInt(T failedValue),
    @required TResult invalidDouble(T failedValue),
    @required TResult invalidPriceComparation(T failedValue),
    @required TResult invalidUrl(T failedValue),
    @required TResult invalidPhoneNumber(T failedValue),
    @required TResult invalidNumber(T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return shortString(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    TResult multiline(T failedValue),
    TResult listTooLong(T failedValue, int max),
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult weakPassword(T failedValue),
    TResult shortString(T failedValue),
    TResult invalidDate(T failedValue),
    TResult invalidMinimumDate(T failedValue),
    TResult invalidInt(T failedValue),
    TResult invalidDouble(T failedValue),
    TResult invalidPriceComparation(T failedValue),
    TResult invalidUrl(T failedValue),
    TResult invalidPhoneNumber(T failedValue),
    TResult invalidNumber(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (shortString != null) {
      return shortString(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult listTooLong(ListTooLong<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult weakPassword(WeakPassword<T> value),
    @required TResult shortString(ShortString<T> value),
    @required TResult invalidDate(InvalidDate<T> value),
    @required TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    @required TResult invalidInt(InvalidInt<T> value),
    @required TResult invalidDouble(InvalidDouble<T> value),
    @required TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    @required TResult invalidUrl(InvalidUrl<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidNumber(InvalidNumber<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return shortString(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    TResult multiline(Multiline<T> value),
    TResult listTooLong(ListTooLong<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult weakPassword(WeakPassword<T> value),
    TResult shortString(ShortString<T> value),
    TResult invalidDate(InvalidDate<T> value),
    TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    TResult invalidInt(InvalidInt<T> value),
    TResult invalidDouble(InvalidDouble<T> value),
    TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    TResult invalidUrl(InvalidUrl<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidNumber(InvalidNumber<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (shortString != null) {
      return shortString(this);
    }
    return orElse();
  }
}

abstract class ShortString<T> implements ValueFailure<T> {
  const factory ShortString({@required T failedValue}) = _$ShortString<T>;

  @override
  T get failedValue;
  @override
  $ShortStringCopyWith<T, ShortString<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidDateCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidDateCopyWith(
          InvalidDate<T> value, $Res Function(InvalidDate<T>) then) =
      _$InvalidDateCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidDateCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidDateCopyWith<T, $Res> {
  _$InvalidDateCopyWithImpl(
      InvalidDate<T> _value, $Res Function(InvalidDate<T>) _then)
      : super(_value, (v) => _then(v as InvalidDate<T>));

  @override
  InvalidDate<T> get _value => super._value as InvalidDate<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidDate<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidDate<T> implements InvalidDate<T> {
  const _$InvalidDate({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidDate(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidDate<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidDateCopyWith<T, InvalidDate<T>> get copyWith =>
      _$InvalidDateCopyWithImpl<T, InvalidDate<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
    @required TResult multiline(T failedValue),
    @required TResult listTooLong(T failedValue, int max),
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult weakPassword(T failedValue),
    @required TResult shortString(T failedValue),
    @required TResult invalidDate(T failedValue),
    @required TResult invalidMinimumDate(T failedValue),
    @required TResult invalidInt(T failedValue),
    @required TResult invalidDouble(T failedValue),
    @required TResult invalidPriceComparation(T failedValue),
    @required TResult invalidUrl(T failedValue),
    @required TResult invalidPhoneNumber(T failedValue),
    @required TResult invalidNumber(T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return invalidDate(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    TResult multiline(T failedValue),
    TResult listTooLong(T failedValue, int max),
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult weakPassword(T failedValue),
    TResult shortString(T failedValue),
    TResult invalidDate(T failedValue),
    TResult invalidMinimumDate(T failedValue),
    TResult invalidInt(T failedValue),
    TResult invalidDouble(T failedValue),
    TResult invalidPriceComparation(T failedValue),
    TResult invalidUrl(T failedValue),
    TResult invalidPhoneNumber(T failedValue),
    TResult invalidNumber(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidDate != null) {
      return invalidDate(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult listTooLong(ListTooLong<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult weakPassword(WeakPassword<T> value),
    @required TResult shortString(ShortString<T> value),
    @required TResult invalidDate(InvalidDate<T> value),
    @required TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    @required TResult invalidInt(InvalidInt<T> value),
    @required TResult invalidDouble(InvalidDouble<T> value),
    @required TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    @required TResult invalidUrl(InvalidUrl<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidNumber(InvalidNumber<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return invalidDate(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    TResult multiline(Multiline<T> value),
    TResult listTooLong(ListTooLong<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult weakPassword(WeakPassword<T> value),
    TResult shortString(ShortString<T> value),
    TResult invalidDate(InvalidDate<T> value),
    TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    TResult invalidInt(InvalidInt<T> value),
    TResult invalidDouble(InvalidDouble<T> value),
    TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    TResult invalidUrl(InvalidUrl<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidNumber(InvalidNumber<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidDate != null) {
      return invalidDate(this);
    }
    return orElse();
  }
}

abstract class InvalidDate<T> implements ValueFailure<T> {
  const factory InvalidDate({@required T failedValue}) = _$InvalidDate<T>;

  @override
  T get failedValue;
  @override
  $InvalidDateCopyWith<T, InvalidDate<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidMinimumDateCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidMinimumDateCopyWith(InvalidMinimumDate<T> value,
          $Res Function(InvalidMinimumDate<T>) then) =
      _$InvalidMinimumDateCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidMinimumDateCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidMinimumDateCopyWith<T, $Res> {
  _$InvalidMinimumDateCopyWithImpl(
      InvalidMinimumDate<T> _value, $Res Function(InvalidMinimumDate<T>) _then)
      : super(_value, (v) => _then(v as InvalidMinimumDate<T>));

  @override
  InvalidMinimumDate<T> get _value => super._value as InvalidMinimumDate<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidMinimumDate<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidMinimumDate<T> implements InvalidMinimumDate<T> {
  const _$InvalidMinimumDate({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidMinimumDate(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidMinimumDate<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidMinimumDateCopyWith<T, InvalidMinimumDate<T>> get copyWith =>
      _$InvalidMinimumDateCopyWithImpl<T, InvalidMinimumDate<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
    @required TResult multiline(T failedValue),
    @required TResult listTooLong(T failedValue, int max),
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult weakPassword(T failedValue),
    @required TResult shortString(T failedValue),
    @required TResult invalidDate(T failedValue),
    @required TResult invalidMinimumDate(T failedValue),
    @required TResult invalidInt(T failedValue),
    @required TResult invalidDouble(T failedValue),
    @required TResult invalidPriceComparation(T failedValue),
    @required TResult invalidUrl(T failedValue),
    @required TResult invalidPhoneNumber(T failedValue),
    @required TResult invalidNumber(T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return invalidMinimumDate(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    TResult multiline(T failedValue),
    TResult listTooLong(T failedValue, int max),
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult weakPassword(T failedValue),
    TResult shortString(T failedValue),
    TResult invalidDate(T failedValue),
    TResult invalidMinimumDate(T failedValue),
    TResult invalidInt(T failedValue),
    TResult invalidDouble(T failedValue),
    TResult invalidPriceComparation(T failedValue),
    TResult invalidUrl(T failedValue),
    TResult invalidPhoneNumber(T failedValue),
    TResult invalidNumber(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidMinimumDate != null) {
      return invalidMinimumDate(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult listTooLong(ListTooLong<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult weakPassword(WeakPassword<T> value),
    @required TResult shortString(ShortString<T> value),
    @required TResult invalidDate(InvalidDate<T> value),
    @required TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    @required TResult invalidInt(InvalidInt<T> value),
    @required TResult invalidDouble(InvalidDouble<T> value),
    @required TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    @required TResult invalidUrl(InvalidUrl<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidNumber(InvalidNumber<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return invalidMinimumDate(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    TResult multiline(Multiline<T> value),
    TResult listTooLong(ListTooLong<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult weakPassword(WeakPassword<T> value),
    TResult shortString(ShortString<T> value),
    TResult invalidDate(InvalidDate<T> value),
    TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    TResult invalidInt(InvalidInt<T> value),
    TResult invalidDouble(InvalidDouble<T> value),
    TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    TResult invalidUrl(InvalidUrl<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidNumber(InvalidNumber<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidMinimumDate != null) {
      return invalidMinimumDate(this);
    }
    return orElse();
  }
}

abstract class InvalidMinimumDate<T> implements ValueFailure<T> {
  const factory InvalidMinimumDate({@required T failedValue}) =
      _$InvalidMinimumDate<T>;

  @override
  T get failedValue;
  @override
  $InvalidMinimumDateCopyWith<T, InvalidMinimumDate<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidIntCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidIntCopyWith(
          InvalidInt<T> value, $Res Function(InvalidInt<T>) then) =
      _$InvalidIntCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidIntCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidIntCopyWith<T, $Res> {
  _$InvalidIntCopyWithImpl(
      InvalidInt<T> _value, $Res Function(InvalidInt<T>) _then)
      : super(_value, (v) => _then(v as InvalidInt<T>));

  @override
  InvalidInt<T> get _value => super._value as InvalidInt<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidInt<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidInt<T> implements InvalidInt<T> {
  const _$InvalidInt({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidInt(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidInt<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidIntCopyWith<T, InvalidInt<T>> get copyWith =>
      _$InvalidIntCopyWithImpl<T, InvalidInt<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
    @required TResult multiline(T failedValue),
    @required TResult listTooLong(T failedValue, int max),
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult weakPassword(T failedValue),
    @required TResult shortString(T failedValue),
    @required TResult invalidDate(T failedValue),
    @required TResult invalidMinimumDate(T failedValue),
    @required TResult invalidInt(T failedValue),
    @required TResult invalidDouble(T failedValue),
    @required TResult invalidPriceComparation(T failedValue),
    @required TResult invalidUrl(T failedValue),
    @required TResult invalidPhoneNumber(T failedValue),
    @required TResult invalidNumber(T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return invalidInt(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    TResult multiline(T failedValue),
    TResult listTooLong(T failedValue, int max),
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult weakPassword(T failedValue),
    TResult shortString(T failedValue),
    TResult invalidDate(T failedValue),
    TResult invalidMinimumDate(T failedValue),
    TResult invalidInt(T failedValue),
    TResult invalidDouble(T failedValue),
    TResult invalidPriceComparation(T failedValue),
    TResult invalidUrl(T failedValue),
    TResult invalidPhoneNumber(T failedValue),
    TResult invalidNumber(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidInt != null) {
      return invalidInt(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult listTooLong(ListTooLong<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult weakPassword(WeakPassword<T> value),
    @required TResult shortString(ShortString<T> value),
    @required TResult invalidDate(InvalidDate<T> value),
    @required TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    @required TResult invalidInt(InvalidInt<T> value),
    @required TResult invalidDouble(InvalidDouble<T> value),
    @required TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    @required TResult invalidUrl(InvalidUrl<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidNumber(InvalidNumber<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return invalidInt(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    TResult multiline(Multiline<T> value),
    TResult listTooLong(ListTooLong<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult weakPassword(WeakPassword<T> value),
    TResult shortString(ShortString<T> value),
    TResult invalidDate(InvalidDate<T> value),
    TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    TResult invalidInt(InvalidInt<T> value),
    TResult invalidDouble(InvalidDouble<T> value),
    TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    TResult invalidUrl(InvalidUrl<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidNumber(InvalidNumber<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidInt != null) {
      return invalidInt(this);
    }
    return orElse();
  }
}

abstract class InvalidInt<T> implements ValueFailure<T> {
  const factory InvalidInt({@required T failedValue}) = _$InvalidInt<T>;

  @override
  T get failedValue;
  @override
  $InvalidIntCopyWith<T, InvalidInt<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidDoubleCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidDoubleCopyWith(
          InvalidDouble<T> value, $Res Function(InvalidDouble<T>) then) =
      _$InvalidDoubleCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidDoubleCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidDoubleCopyWith<T, $Res> {
  _$InvalidDoubleCopyWithImpl(
      InvalidDouble<T> _value, $Res Function(InvalidDouble<T>) _then)
      : super(_value, (v) => _then(v as InvalidDouble<T>));

  @override
  InvalidDouble<T> get _value => super._value as InvalidDouble<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidDouble<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidDouble<T> implements InvalidDouble<T> {
  const _$InvalidDouble({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidDouble(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidDouble<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidDoubleCopyWith<T, InvalidDouble<T>> get copyWith =>
      _$InvalidDoubleCopyWithImpl<T, InvalidDouble<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
    @required TResult multiline(T failedValue),
    @required TResult listTooLong(T failedValue, int max),
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult weakPassword(T failedValue),
    @required TResult shortString(T failedValue),
    @required TResult invalidDate(T failedValue),
    @required TResult invalidMinimumDate(T failedValue),
    @required TResult invalidInt(T failedValue),
    @required TResult invalidDouble(T failedValue),
    @required TResult invalidPriceComparation(T failedValue),
    @required TResult invalidUrl(T failedValue),
    @required TResult invalidPhoneNumber(T failedValue),
    @required TResult invalidNumber(T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return invalidDouble(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    TResult multiline(T failedValue),
    TResult listTooLong(T failedValue, int max),
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult weakPassword(T failedValue),
    TResult shortString(T failedValue),
    TResult invalidDate(T failedValue),
    TResult invalidMinimumDate(T failedValue),
    TResult invalidInt(T failedValue),
    TResult invalidDouble(T failedValue),
    TResult invalidPriceComparation(T failedValue),
    TResult invalidUrl(T failedValue),
    TResult invalidPhoneNumber(T failedValue),
    TResult invalidNumber(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidDouble != null) {
      return invalidDouble(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult listTooLong(ListTooLong<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult weakPassword(WeakPassword<T> value),
    @required TResult shortString(ShortString<T> value),
    @required TResult invalidDate(InvalidDate<T> value),
    @required TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    @required TResult invalidInt(InvalidInt<T> value),
    @required TResult invalidDouble(InvalidDouble<T> value),
    @required TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    @required TResult invalidUrl(InvalidUrl<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidNumber(InvalidNumber<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return invalidDouble(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    TResult multiline(Multiline<T> value),
    TResult listTooLong(ListTooLong<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult weakPassword(WeakPassword<T> value),
    TResult shortString(ShortString<T> value),
    TResult invalidDate(InvalidDate<T> value),
    TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    TResult invalidInt(InvalidInt<T> value),
    TResult invalidDouble(InvalidDouble<T> value),
    TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    TResult invalidUrl(InvalidUrl<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidNumber(InvalidNumber<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidDouble != null) {
      return invalidDouble(this);
    }
    return orElse();
  }
}

abstract class InvalidDouble<T> implements ValueFailure<T> {
  const factory InvalidDouble({@required T failedValue}) = _$InvalidDouble<T>;

  @override
  T get failedValue;
  @override
  $InvalidDoubleCopyWith<T, InvalidDouble<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidPriceComparationCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidPriceComparationCopyWith(InvalidPriceComparation<T> value,
          $Res Function(InvalidPriceComparation<T>) then) =
      _$InvalidPriceComparationCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidPriceComparationCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidPriceComparationCopyWith<T, $Res> {
  _$InvalidPriceComparationCopyWithImpl(InvalidPriceComparation<T> _value,
      $Res Function(InvalidPriceComparation<T>) _then)
      : super(_value, (v) => _then(v as InvalidPriceComparation<T>));

  @override
  InvalidPriceComparation<T> get _value =>
      super._value as InvalidPriceComparation<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidPriceComparation<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidPriceComparation<T> implements InvalidPriceComparation<T> {
  const _$InvalidPriceComparation({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidPriceComparation(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidPriceComparation<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidPriceComparationCopyWith<T, InvalidPriceComparation<T>>
      get copyWith =>
          _$InvalidPriceComparationCopyWithImpl<T, InvalidPriceComparation<T>>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
    @required TResult multiline(T failedValue),
    @required TResult listTooLong(T failedValue, int max),
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult weakPassword(T failedValue),
    @required TResult shortString(T failedValue),
    @required TResult invalidDate(T failedValue),
    @required TResult invalidMinimumDate(T failedValue),
    @required TResult invalidInt(T failedValue),
    @required TResult invalidDouble(T failedValue),
    @required TResult invalidPriceComparation(T failedValue),
    @required TResult invalidUrl(T failedValue),
    @required TResult invalidPhoneNumber(T failedValue),
    @required TResult invalidNumber(T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return invalidPriceComparation(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    TResult multiline(T failedValue),
    TResult listTooLong(T failedValue, int max),
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult weakPassword(T failedValue),
    TResult shortString(T failedValue),
    TResult invalidDate(T failedValue),
    TResult invalidMinimumDate(T failedValue),
    TResult invalidInt(T failedValue),
    TResult invalidDouble(T failedValue),
    TResult invalidPriceComparation(T failedValue),
    TResult invalidUrl(T failedValue),
    TResult invalidPhoneNumber(T failedValue),
    TResult invalidNumber(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidPriceComparation != null) {
      return invalidPriceComparation(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult listTooLong(ListTooLong<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult weakPassword(WeakPassword<T> value),
    @required TResult shortString(ShortString<T> value),
    @required TResult invalidDate(InvalidDate<T> value),
    @required TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    @required TResult invalidInt(InvalidInt<T> value),
    @required TResult invalidDouble(InvalidDouble<T> value),
    @required TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    @required TResult invalidUrl(InvalidUrl<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidNumber(InvalidNumber<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return invalidPriceComparation(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    TResult multiline(Multiline<T> value),
    TResult listTooLong(ListTooLong<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult weakPassword(WeakPassword<T> value),
    TResult shortString(ShortString<T> value),
    TResult invalidDate(InvalidDate<T> value),
    TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    TResult invalidInt(InvalidInt<T> value),
    TResult invalidDouble(InvalidDouble<T> value),
    TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    TResult invalidUrl(InvalidUrl<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidNumber(InvalidNumber<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidPriceComparation != null) {
      return invalidPriceComparation(this);
    }
    return orElse();
  }
}

abstract class InvalidPriceComparation<T> implements ValueFailure<T> {
  const factory InvalidPriceComparation({@required T failedValue}) =
      _$InvalidPriceComparation<T>;

  @override
  T get failedValue;
  @override
  $InvalidPriceComparationCopyWith<T, InvalidPriceComparation<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidUrlCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidUrlCopyWith(
          InvalidUrl<T> value, $Res Function(InvalidUrl<T>) then) =
      _$InvalidUrlCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidUrlCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidUrlCopyWith<T, $Res> {
  _$InvalidUrlCopyWithImpl(
      InvalidUrl<T> _value, $Res Function(InvalidUrl<T>) _then)
      : super(_value, (v) => _then(v as InvalidUrl<T>));

  @override
  InvalidUrl<T> get _value => super._value as InvalidUrl<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidUrl<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidUrl<T> implements InvalidUrl<T> {
  const _$InvalidUrl({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidUrl(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidUrl<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidUrlCopyWith<T, InvalidUrl<T>> get copyWith =>
      _$InvalidUrlCopyWithImpl<T, InvalidUrl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
    @required TResult multiline(T failedValue),
    @required TResult listTooLong(T failedValue, int max),
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult weakPassword(T failedValue),
    @required TResult shortString(T failedValue),
    @required TResult invalidDate(T failedValue),
    @required TResult invalidMinimumDate(T failedValue),
    @required TResult invalidInt(T failedValue),
    @required TResult invalidDouble(T failedValue),
    @required TResult invalidPriceComparation(T failedValue),
    @required TResult invalidUrl(T failedValue),
    @required TResult invalidPhoneNumber(T failedValue),
    @required TResult invalidNumber(T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return invalidUrl(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    TResult multiline(T failedValue),
    TResult listTooLong(T failedValue, int max),
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult weakPassword(T failedValue),
    TResult shortString(T failedValue),
    TResult invalidDate(T failedValue),
    TResult invalidMinimumDate(T failedValue),
    TResult invalidInt(T failedValue),
    TResult invalidDouble(T failedValue),
    TResult invalidPriceComparation(T failedValue),
    TResult invalidUrl(T failedValue),
    TResult invalidPhoneNumber(T failedValue),
    TResult invalidNumber(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidUrl != null) {
      return invalidUrl(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult listTooLong(ListTooLong<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult weakPassword(WeakPassword<T> value),
    @required TResult shortString(ShortString<T> value),
    @required TResult invalidDate(InvalidDate<T> value),
    @required TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    @required TResult invalidInt(InvalidInt<T> value),
    @required TResult invalidDouble(InvalidDouble<T> value),
    @required TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    @required TResult invalidUrl(InvalidUrl<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidNumber(InvalidNumber<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return invalidUrl(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    TResult multiline(Multiline<T> value),
    TResult listTooLong(ListTooLong<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult weakPassword(WeakPassword<T> value),
    TResult shortString(ShortString<T> value),
    TResult invalidDate(InvalidDate<T> value),
    TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    TResult invalidInt(InvalidInt<T> value),
    TResult invalidDouble(InvalidDouble<T> value),
    TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    TResult invalidUrl(InvalidUrl<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidNumber(InvalidNumber<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidUrl != null) {
      return invalidUrl(this);
    }
    return orElse();
  }
}

abstract class InvalidUrl<T> implements ValueFailure<T> {
  const factory InvalidUrl({@required T failedValue}) = _$InvalidUrl<T>;

  @override
  T get failedValue;
  @override
  $InvalidUrlCopyWith<T, InvalidUrl<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidPhoneNumberCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidPhoneNumberCopyWith(InvalidPhoneNumber<T> value,
          $Res Function(InvalidPhoneNumber<T>) then) =
      _$InvalidPhoneNumberCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidPhoneNumberCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidPhoneNumberCopyWith<T, $Res> {
  _$InvalidPhoneNumberCopyWithImpl(
      InvalidPhoneNumber<T> _value, $Res Function(InvalidPhoneNumber<T>) _then)
      : super(_value, (v) => _then(v as InvalidPhoneNumber<T>));

  @override
  InvalidPhoneNumber<T> get _value => super._value as InvalidPhoneNumber<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidPhoneNumber<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidPhoneNumber<T> implements InvalidPhoneNumber<T> {
  const _$InvalidPhoneNumber({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidPhoneNumber(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidPhoneNumber<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidPhoneNumberCopyWith<T, InvalidPhoneNumber<T>> get copyWith =>
      _$InvalidPhoneNumberCopyWithImpl<T, InvalidPhoneNumber<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
    @required TResult multiline(T failedValue),
    @required TResult listTooLong(T failedValue, int max),
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult weakPassword(T failedValue),
    @required TResult shortString(T failedValue),
    @required TResult invalidDate(T failedValue),
    @required TResult invalidMinimumDate(T failedValue),
    @required TResult invalidInt(T failedValue),
    @required TResult invalidDouble(T failedValue),
    @required TResult invalidPriceComparation(T failedValue),
    @required TResult invalidUrl(T failedValue),
    @required TResult invalidPhoneNumber(T failedValue),
    @required TResult invalidNumber(T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return invalidPhoneNumber(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    TResult multiline(T failedValue),
    TResult listTooLong(T failedValue, int max),
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult weakPassword(T failedValue),
    TResult shortString(T failedValue),
    TResult invalidDate(T failedValue),
    TResult invalidMinimumDate(T failedValue),
    TResult invalidInt(T failedValue),
    TResult invalidDouble(T failedValue),
    TResult invalidPriceComparation(T failedValue),
    TResult invalidUrl(T failedValue),
    TResult invalidPhoneNumber(T failedValue),
    TResult invalidNumber(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidPhoneNumber != null) {
      return invalidPhoneNumber(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult listTooLong(ListTooLong<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult weakPassword(WeakPassword<T> value),
    @required TResult shortString(ShortString<T> value),
    @required TResult invalidDate(InvalidDate<T> value),
    @required TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    @required TResult invalidInt(InvalidInt<T> value),
    @required TResult invalidDouble(InvalidDouble<T> value),
    @required TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    @required TResult invalidUrl(InvalidUrl<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidNumber(InvalidNumber<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return invalidPhoneNumber(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    TResult multiline(Multiline<T> value),
    TResult listTooLong(ListTooLong<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult weakPassword(WeakPassword<T> value),
    TResult shortString(ShortString<T> value),
    TResult invalidDate(InvalidDate<T> value),
    TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    TResult invalidInt(InvalidInt<T> value),
    TResult invalidDouble(InvalidDouble<T> value),
    TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    TResult invalidUrl(InvalidUrl<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidNumber(InvalidNumber<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidPhoneNumber != null) {
      return invalidPhoneNumber(this);
    }
    return orElse();
  }
}

abstract class InvalidPhoneNumber<T> implements ValueFailure<T> {
  const factory InvalidPhoneNumber({@required T failedValue}) =
      _$InvalidPhoneNumber<T>;

  @override
  T get failedValue;
  @override
  $InvalidPhoneNumberCopyWith<T, InvalidPhoneNumber<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidNumberCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidNumberCopyWith(
          InvalidNumber<T> value, $Res Function(InvalidNumber<T>) then) =
      _$InvalidNumberCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidNumberCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidNumberCopyWith<T, $Res> {
  _$InvalidNumberCopyWithImpl(
      InvalidNumber<T> _value, $Res Function(InvalidNumber<T>) _then)
      : super(_value, (v) => _then(v as InvalidNumber<T>));

  @override
  InvalidNumber<T> get _value => super._value as InvalidNumber<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidNumber<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidNumber<T> implements InvalidNumber<T> {
  const _$InvalidNumber({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidNumber(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidNumber<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidNumberCopyWith<T, InvalidNumber<T>> get copyWith =>
      _$InvalidNumberCopyWithImpl<T, InvalidNumber<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
    @required TResult multiline(T failedValue),
    @required TResult listTooLong(T failedValue, int max),
    @required TResult invalidEmail(T failedValue),
    @required TResult shortPassword(T failedValue),
    @required TResult weakPassword(T failedValue),
    @required TResult shortString(T failedValue),
    @required TResult invalidDate(T failedValue),
    @required TResult invalidMinimumDate(T failedValue),
    @required TResult invalidInt(T failedValue),
    @required TResult invalidDouble(T failedValue),
    @required TResult invalidPriceComparation(T failedValue),
    @required TResult invalidUrl(T failedValue),
    @required TResult invalidPhoneNumber(T failedValue),
    @required TResult invalidNumber(T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return invalidNumber(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    TResult multiline(T failedValue),
    TResult listTooLong(T failedValue, int max),
    TResult invalidEmail(T failedValue),
    TResult shortPassword(T failedValue),
    TResult weakPassword(T failedValue),
    TResult shortString(T failedValue),
    TResult invalidDate(T failedValue),
    TResult invalidMinimumDate(T failedValue),
    TResult invalidInt(T failedValue),
    TResult invalidDouble(T failedValue),
    TResult invalidPriceComparation(T failedValue),
    TResult invalidUrl(T failedValue),
    TResult invalidPhoneNumber(T failedValue),
    TResult invalidNumber(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidNumber != null) {
      return invalidNumber(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult listTooLong(ListTooLong<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult shortPassword(ShortPassword<T> value),
    @required TResult weakPassword(WeakPassword<T> value),
    @required TResult shortString(ShortString<T> value),
    @required TResult invalidDate(InvalidDate<T> value),
    @required TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    @required TResult invalidInt(InvalidInt<T> value),
    @required TResult invalidDouble(InvalidDouble<T> value),
    @required TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    @required TResult invalidUrl(InvalidUrl<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidNumber(InvalidNumber<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(listTooLong != null);
    assert(invalidEmail != null);
    assert(shortPassword != null);
    assert(weakPassword != null);
    assert(shortString != null);
    assert(invalidDate != null);
    assert(invalidMinimumDate != null);
    assert(invalidInt != null);
    assert(invalidDouble != null);
    assert(invalidPriceComparation != null);
    assert(invalidUrl != null);
    assert(invalidPhoneNumber != null);
    assert(invalidNumber != null);
    return invalidNumber(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    TResult multiline(Multiline<T> value),
    TResult listTooLong(ListTooLong<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult shortPassword(ShortPassword<T> value),
    TResult weakPassword(WeakPassword<T> value),
    TResult shortString(ShortString<T> value),
    TResult invalidDate(InvalidDate<T> value),
    TResult invalidMinimumDate(InvalidMinimumDate<T> value),
    TResult invalidInt(InvalidInt<T> value),
    TResult invalidDouble(InvalidDouble<T> value),
    TResult invalidPriceComparation(InvalidPriceComparation<T> value),
    TResult invalidUrl(InvalidUrl<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidNumber(InvalidNumber<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidNumber != null) {
      return invalidNumber(this);
    }
    return orElse();
  }
}

abstract class InvalidNumber<T> implements ValueFailure<T> {
  const factory InvalidNumber({@required T failedValue}) = _$InvalidNumber<T>;

  @override
  T get failedValue;
  @override
  $InvalidNumberCopyWith<T, InvalidNumber<T>> get copyWith;
}
